{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar noop = require(\"./noop\");\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\n\n\nvar Span =\n/** @class */\nfunction () {\n  function Span() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Returns the SpanContext object associated with this Span.\n   *\n   * @return {SpanContext}\n   */\n\n\n  Span.prototype.context = function () {\n    return this._context();\n  };\n  /**\n   * Returns the Tracer object used to create this Span.\n   *\n   * @return {Tracer}\n   */\n\n\n  Span.prototype.tracer = function () {\n    return this._tracer();\n  };\n  /**\n   * Sets the string name for the logical operation this span represents.\n   *\n   * @param {string} name\n   */\n\n\n  Span.prototype.setOperationName = function (name) {\n    this._setOperationName(name);\n\n    return this;\n  };\n  /**\n   * Sets a key:value pair on this Span that also propagates to future\n   * children of the associated Span.\n   *\n   * setBaggageItem() enables powerful functionality given a full-stack\n   * opentracing integration (e.g., arbitrary application data from a web\n   * client can make it, transparently, all the way into the depths of a\n   * storage system), and with it some powerful costs: use this feature with\n   * care.\n   *\n   * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n   * *future* causal descendants of the associated Span.\n   *\n   * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n   * value is copied into every local *and remote* child of the associated\n   * Span, and that can add up to a lot of network and cpu overhead.\n   *\n   * @param {string} key\n   * @param {string} value\n   */\n\n\n  Span.prototype.setBaggageItem = function (key, value) {\n    this._setBaggageItem(key, value);\n\n    return this;\n  };\n  /**\n   * Returns the value for a baggage item given its key.\n   *\n   * @param  {string} key\n   *         The key for the given trace attribute.\n   * @return {string}\n   *         String value for the given key, or undefined if the key does not\n   *         correspond to a set trace attribute.\n   */\n\n\n  Span.prototype.getBaggageItem = function (key) {\n    return this._getBaggageItem(key);\n  };\n  /**\n   * Adds a single tag to the span.  See `addTags()` for details.\n   *\n   * @param {string} key\n   * @param {any} value\n   */\n\n\n  Span.prototype.setTag = function (key, value) {\n    var _a; // NOTE: the call is normalized to a call to _addTags()\n\n\n    this._addTags((_a = {}, _a[key] = value, _a));\n\n    return this;\n  };\n  /**\n   * Adds the given key value pairs to the set of span tags.\n   *\n   * Multiple calls to addTags() results in the tags being the superset of\n   * all calls.\n   *\n   * The behavior of setting the same key multiple times on the same span\n   * is undefined.\n   *\n   * The supported type of the values is implementation-dependent.\n   * Implementations are expected to safely handle all types of values but\n   * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n   * with cyclic references, function objects).\n   *\n   * @return {[type]} [description]\n   */\n\n\n  Span.prototype.addTags = function (keyValueMap) {\n    this._addTags(keyValueMap);\n\n    return this;\n  };\n  /**\n   * Add a log record to this Span, optionally at a user-provided timestamp.\n   *\n   * For example:\n   *\n   *     span.log({\n   *         size: rpc.size(),  // numeric value\n   *         URI: rpc.URI(),  // string value\n   *         payload: rpc.payload(),  // Object value\n   *         \"keys can be arbitrary strings\": rpc.foo(),\n   *     });\n   *\n   *     span.log({\n   *         \"error.description\": someError.description(),\n   *     }, someError.timestampMillis());\n   *\n   * @param {object} keyValuePairs\n   *        An object mapping string keys to arbitrary value types. All\n   *        Tracer implementations should support bool, string, and numeric\n   *        value types, and some may also support Object values.\n   * @param {number} timestamp\n   *        An optional parameter specifying the timestamp in milliseconds\n   *        since the Unix epoch. Fractional values are allowed so that\n   *        timestamps with sub-millisecond accuracy can be represented. If\n   *        not specified, the implementation is expected to use its notion\n   *        of the current time of the call.\n   */\n\n\n  Span.prototype.log = function (keyValuePairs, timestamp) {\n    this._log(keyValuePairs, timestamp);\n\n    return this;\n  };\n  /**\n   * DEPRECATED\n   */\n\n\n  Span.prototype.logEvent = function (eventName, payload) {\n    return this._log({\n      event: eventName,\n      payload: payload\n    });\n  };\n  /**\n   * Sets the end timestamp and finalizes Span state.\n   *\n   * With the exception of calls to Span.context() (which are always allowed),\n   * finish() must be the last call made to any span instance, and to do\n   * otherwise leads to undefined behavior.\n   *\n   * @param  {number} finishTime\n   *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n   *         values are supported for timestamps with sub-millisecond accuracy.\n   *         If not specified, the current time (as defined by the\n   *         implementation) will be used.\n   */\n\n\n  Span.prototype.finish = function (finishTime) {\n    this._finish(finishTime); // Do not return `this`. The Span generally should not be used after it\n    // is finished so chaining is not desired in this context.\n\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // By default returns a no-op SpanContext.\n\n\n  Span.prototype._context = function () {\n    return noop.spanContext;\n  }; // By default returns a no-op tracer.\n  //\n  // The base class could store the tracer that created it, but it does not\n  // in order to ensure the no-op span implementation has zero members,\n  // which allows V8 to aggressively optimize calls to such objects.\n\n\n  Span.prototype._tracer = function () {\n    return noop.tracer;\n  }; // By default does nothing\n\n\n  Span.prototype._setOperationName = function (name) {}; // By default does nothing\n\n\n  Span.prototype._setBaggageItem = function (key, value) {}; // By default does nothing\n\n\n  Span.prototype._getBaggageItem = function (key) {\n    return undefined;\n  }; // By default does nothing\n  //\n  // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n  // will always be an associative array.\n\n\n  Span.prototype._addTags = function (keyValuePairs) {}; // By default does nothing\n\n\n  Span.prototype._log = function (keyValuePairs, timestamp) {}; // By default does nothing\n  //\n  // finishTime is expected to be either a number or undefined.\n\n\n  Span.prototype._finish = function (finishTime) {};\n\n  return Span;\n}();\n\nexports.Span = Span;\nexports.default = Span; //# sourceMappingURL=span.js.map","map":null,"metadata":{},"sourceType":"script"}