{"ast":null,"code":"import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: {\n    score: 0,\n    firstEntryTime: Number.NEGATIVE_INFINITY,\n    prevEntryTime: Number.NEGATIVE_INFINITY,\n    currentSessionScore: 0\n  },\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      var shouldCreateNewSession = entry.startTime - metrics.cls.firstEntryTime > 5000 || entry.startTime - metrics.cls.prevEntryTime > 1000;\n\n      if (shouldCreateNewSession) {\n        metrics.cls.firstEntryTime = entry.startTime;\n        metrics.cls.currentSessionScore = 0;\n      }\n\n      metrics.cls.prevEntryTime = entry.startTime;\n      metrics.cls.currentSessionScore += entry.value;\n      metrics.cls.score = Math.max(metrics.cls.score, metrics.cls.currentSessionScore);\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();","map":null,"metadata":{},"sourceType":"module"}