{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Functions = require(\"./functions\");\n\nvar Noop = require(\"./noop\");\n\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\n\n\nvar Tracer =\n/** @class */\nfunction () {\n  function Tracer() {} // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * For example:\n   *\n   *     // Start a new (parentless) root Span:\n   *     var parent = Tracer.startSpan('DoWork');\n   *\n   *     // Start a new (child) Span:\n   *     var child = Tracer.startSpan('load-from-db', {\n   *         childOf: parent.context(),\n   *     });\n   *\n   *     // Start a new async (FollowsFrom) Span:\n   *     var child = Tracer.startSpan('async-cache-write', {\n   *         references: [\n   *             opentracing.followsFrom(parent.context())\n   *         ],\n   *     });\n   *\n   * @param {string} name - the name of the operation (REQUIRED).\n   * @param {SpanOptions} [options] - options for the newly created span.\n   * @return {Span} - a new Span object.\n   */\n\n\n  Tracer.prototype.startSpan = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    } // Convert options.childOf to fields.references as needed.\n\n\n    if (options.childOf) {\n      // Convert from a Span or a SpanContext into a Reference.\n      var childOf = Functions.childOf(options.childOf);\n\n      if (options.references) {\n        options.references.push(childOf);\n      } else {\n        options.references = [childOf];\n      }\n\n      delete options.childOf;\n    }\n\n    return this._startSpan(name, options);\n  };\n  /**\n   * Injects the given SpanContext instance for cross-process propagation\n   * within `carrier`. The expected type of `carrier` depends on the value of\n   * `format.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     var clientSpan = ...;\n   *     ...\n   *     // Inject clientSpan into a text carrier.\n   *     var headersCarrier = {};\n   *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     // Incorporate the textCarrier into the outbound HTTP request header\n   *     // map.\n   *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n   *     // ... send the httpReq\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   */\n\n\n  Tracer.prototype.inject = function (spanContext, format, carrier) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n      spanContext = spanContext.context();\n    }\n\n    return this._inject(spanContext, format, carrier);\n  };\n  /**\n   * Returns a SpanContext instance extracted from `carrier` in the given\n   * `format`.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     // Use the inbound HTTP request's headers as a text map carrier.\n   *     var headersCarrier = inboundHTTPReq.headers;\n   *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n\n\n  Tracer.prototype.extract = function (format, carrier) {\n    return this._extract(format, carrier);\n  }; // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // NOTE: the input to this method is *always* an associative array. The\n  // public-facing startSpan() method normalizes the arguments so that\n  // all N implementations do not need to worry about variations in the call\n  // signature.\n  //\n  // The default behavior returns a no-op span.\n\n\n  Tracer.prototype._startSpan = function (name, fields) {\n    return Noop.span;\n  }; // The default behavior is a no-op.\n\n\n  Tracer.prototype._inject = function (spanContext, format, carrier) {}; // The default behavior is to return a no-op SpanContext.\n\n\n  Tracer.prototype._extract = function (format, carrier) {\n    return Noop.spanContext;\n  };\n\n  return Tracer;\n}();\n\nexports.Tracer = Tracer;\nexports.default = Tracer; //# sourceMappingURL=tracer.js.map","map":null,"metadata":{},"sourceType":"script"}