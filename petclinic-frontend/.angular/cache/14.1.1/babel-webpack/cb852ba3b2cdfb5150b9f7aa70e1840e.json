{"ast":null,"code":"import { Promise } from '../polyfills';\nimport { globalState } from './patch-utils';\nimport { SCHEDULE, INVOKE, FETCH } from '../constants';\nimport { scheduleMicroTask } from '../utils';\nimport { isFetchSupported } from '../http/fetch';\nexport function patchFetch(callback) {\n  if (!isFetchSupported()) {\n    return;\n  }\n\n  function scheduleTask(task) {\n    task.state = SCHEDULE;\n    callback(SCHEDULE, task);\n  }\n\n  function invokeTask(task) {\n    task.state = INVOKE;\n    callback(INVOKE, task);\n  }\n\n  function handleResponseError(task, error) {\n    task.data.aborted = isAbortError(error);\n    task.data.error = error;\n    invokeTask(task);\n  }\n\n  function readStream(stream, task) {\n    var reader = stream.getReader();\n\n    var read = function read() {\n      reader.read().then(function (_ref) {\n        var done = _ref.done;\n\n        if (done) {\n          invokeTask(task);\n        } else {\n          read();\n        }\n      }, function (error) {\n        handleResponseError(task, error);\n      });\n    };\n\n    read();\n  }\n\n  var nativeFetch = window.fetch;\n\n  window.fetch = function (input, init) {\n    var fetchSelf = this;\n    var args = arguments;\n    var request, url;\n\n    if (typeof input === 'string') {\n      request = new Request(input, init);\n      url = input;\n    } else if (input) {\n      request = input;\n      url = request.url;\n    } else {\n      return nativeFetch.apply(fetchSelf, args);\n    }\n\n    var task = {\n      source: FETCH,\n      state: '',\n      type: 'macroTask',\n      data: {\n        target: request,\n        method: request.method,\n        url: url,\n        aborted: false\n      }\n    };\n    return new Promise(function (resolve, reject) {\n      globalState.fetchInProgress = true;\n      scheduleTask(task);\n      var promise;\n\n      try {\n        promise = nativeFetch.apply(fetchSelf, [request]);\n      } catch (error) {\n        reject(error);\n        task.data.error = error;\n        invokeTask(task);\n        globalState.fetchInProgress = false;\n        return;\n      }\n\n      promise.then(function (response) {\n        var clonedResponse = response.clone ? response.clone() : {};\n        resolve(response);\n        scheduleMicroTask(function () {\n          task.data.response = response;\n          var body = clonedResponse.body;\n\n          if (body) {\n            readStream(body, task);\n          } else {\n            invokeTask(task);\n          }\n        });\n      }, function (error) {\n        reject(error);\n        scheduleMicroTask(function () {\n          handleResponseError(task, error);\n        });\n      });\n      globalState.fetchInProgress = false;\n    });\n  };\n}\n\nfunction isAbortError(error) {\n  return error && error.name === 'AbortError';\n}","map":null,"metadata":{},"sourceType":"module"}