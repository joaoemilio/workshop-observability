{"ast":null,"code":"import { isBrowser } from './utils';\n\nfunction isDefaultPort(port, protocol) {\n  switch (protocol) {\n    case 'http:':\n      return port === '80';\n\n    case 'https:':\n      return port === '443';\n  }\n\n  return true;\n}\n\nvar RULES = [['#', 'hash'], ['?', 'query'], ['/', 'path'], ['@', 'auth', 1], [NaN, 'host', undefined, 1]];\nvar PROTOCOL_REGEX = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i;\nexport var Url = function () {\n  function Url(url) {\n    var _this$extractProtocol = this.extractProtocol(url || ''),\n        protocol = _this$extractProtocol.protocol,\n        address = _this$extractProtocol.address,\n        slashes = _this$extractProtocol.slashes;\n\n    var relative = !protocol && !slashes;\n    var location = this.getLocation();\n    var instructions = RULES.slice();\n    address = address.replace('\\\\', '/');\n\n    if (!slashes) {\n      instructions[2] = [NaN, 'path'];\n    }\n\n    var index;\n\n    for (var i = 0; i < instructions.length; i++) {\n      var instruction = instructions[i];\n      var parse = instruction[0];\n      var key = instruction[1];\n\n      if (typeof parse === 'string') {\n        index = address.indexOf(parse);\n\n        if (~index) {\n          var instLength = instruction[2];\n\n          if (instLength) {\n            var newIndex = address.lastIndexOf(parse);\n            index = Math.max(index, newIndex);\n            this[key] = address.slice(0, index);\n            address = address.slice(index + instLength);\n          } else {\n            this[key] = address.slice(index);\n            address = address.slice(0, index);\n          }\n        }\n      } else {\n        this[key] = address;\n        address = '';\n      }\n\n      this[key] = this[key] || (relative && instruction[3] ? location[key] || '' : '');\n      if (instruction[3]) this[key] = this[key].toLowerCase();\n    }\n\n    if (relative && this.path.charAt(0) !== '/') {\n      this.path = '/' + this.path;\n    }\n\n    this.relative = relative;\n    this.protocol = protocol || location.protocol;\n    this.hostname = this.host;\n    this.port = '';\n\n    if (/:\\d+$/.test(this.host)) {\n      var value = this.host.split(':');\n      var port = value.pop();\n      var hostname = value.join(':');\n\n      if (isDefaultPort(port, this.protocol)) {\n        this.host = hostname;\n      } else {\n        this.port = port;\n      }\n\n      this.hostname = hostname;\n    }\n\n    this.origin = this.protocol && this.host && this.protocol !== 'file:' ? this.protocol + '//' + this.host : 'null';\n    this.href = this.toString();\n  }\n\n  var _proto = Url.prototype;\n\n  _proto.toString = function toString() {\n    var result = this.protocol;\n    result += '//';\n\n    if (this.auth) {\n      var REDACTED = '[REDACTED]';\n      var userpass = this.auth.split(':');\n      var username = userpass[0] ? REDACTED : '';\n      var password = userpass[1] ? ':' + REDACTED : '';\n      result += username + password + '@';\n    }\n\n    result += this.host;\n    result += this.path;\n    result += this.query;\n    result += this.hash;\n    return result;\n  };\n\n  _proto.getLocation = function getLocation() {\n    var globalVar = {};\n\n    if (isBrowser) {\n      globalVar = window;\n    }\n\n    return globalVar.location;\n  };\n\n  _proto.extractProtocol = function extractProtocol(url) {\n    var match = PROTOCOL_REGEX.exec(url);\n    return {\n      protocol: match[1] ? match[1].toLowerCase() : '',\n      slashes: !!match[2],\n      address: match[3]\n    };\n  };\n\n  return Url;\n}();\nexport function slugifyUrl(urlStr, depth) {\n  if (depth === void 0) {\n    depth = 2;\n  }\n\n  var parsedUrl = new Url(urlStr);\n  var query = parsedUrl.query,\n      path = parsedUrl.path;\n  var pathParts = path.substring(1).split('/');\n  var redactString = ':id';\n  var wildcard = '*';\n  var specialCharsRegex = /\\W|_/g;\n  var digitsRegex = /[0-9]/g;\n  var lowerCaseRegex = /[a-z]/g;\n  var upperCaseRegex = /[A-Z]/g;\n  var redactedParts = [];\n  var redactedBefore = false;\n\n  for (var index = 0; index < pathParts.length; index++) {\n    var part = pathParts[index];\n\n    if (redactedBefore || index > depth - 1) {\n      if (part) {\n        redactedParts.push(wildcard);\n      }\n\n      break;\n    }\n\n    var numberOfSpecialChars = (part.match(specialCharsRegex) || []).length;\n\n    if (numberOfSpecialChars >= 2) {\n      redactedParts.push(redactString);\n      redactedBefore = true;\n      continue;\n    }\n\n    var numberOfDigits = (part.match(digitsRegex) || []).length;\n\n    if (numberOfDigits > 3 || part.length > 3 && numberOfDigits / part.length >= 0.3) {\n      redactedParts.push(redactString);\n      redactedBefore = true;\n      continue;\n    }\n\n    var numberofUpperCase = (part.match(upperCaseRegex) || []).length;\n    var numberofLowerCase = (part.match(lowerCaseRegex) || []).length;\n    var lowerCaseRate = numberofLowerCase / part.length;\n    var upperCaseRate = numberofUpperCase / part.length;\n\n    if (part.length > 5 && (upperCaseRate > 0.3 && upperCaseRate < 0.6 || lowerCaseRate > 0.3 && lowerCaseRate < 0.6)) {\n      redactedParts.push(redactString);\n      redactedBefore = true;\n      continue;\n    }\n\n    part && redactedParts.push(part);\n  }\n\n  var redacted = '/' + (redactedParts.length >= 2 ? redactedParts.join('/') : redactedParts.join('')) + (query ? '?{query}' : '');\n  return redacted;\n}","map":null,"metadata":{},"sourceType":"module"}