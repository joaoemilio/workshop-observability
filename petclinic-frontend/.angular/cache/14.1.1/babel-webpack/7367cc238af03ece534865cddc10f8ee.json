{"ast":null,"code":"import Span from './span';\nimport { RESOURCE_INITIATOR_TYPES, MAX_SPAN_DURATION, USER_TIMING_THRESHOLD, PAGE_LOAD, RESOURCE, MEASURE } from '../common/constants';\nimport { stripQueryStringFromUrl, PERF, isPerfTimelineSupported } from '../common/utils';\nimport { state } from '../state';\nvar eventPairs = [['domainLookupStart', 'domainLookupEnd', 'Domain lookup'], ['connectStart', 'connectEnd', 'Making a connection to the server'], ['requestStart', 'responseEnd', 'Requesting and receiving the document'], ['domLoading', 'domInteractive', 'Parsing the document, executing sync. scripts'], ['domContentLoadedEventStart', 'domContentLoadedEventEnd', 'Fire \"DOMContentLoaded\" event'], ['loadEventStart', 'loadEventEnd', 'Fire \"load\" event']];\n\nfunction shouldCreateSpan(start, end, trStart, trEnd, baseTime) {\n  if (baseTime === void 0) {\n    baseTime = 0;\n  }\n\n  return typeof start === 'number' && typeof end === 'number' && start >= baseTime && end > start && start - baseTime >= trStart && end - baseTime <= trEnd && end - start < MAX_SPAN_DURATION && start - baseTime < MAX_SPAN_DURATION && end - baseTime < MAX_SPAN_DURATION;\n}\n\nfunction createNavigationTimingSpans(timings, baseTime, trStart, trEnd) {\n  var spans = [];\n\n  for (var i = 0; i < eventPairs.length; i++) {\n    var start = timings[eventPairs[i][0]];\n    var end = timings[eventPairs[i][1]];\n\n    if (!shouldCreateSpan(start, end, trStart, trEnd, baseTime)) {\n      continue;\n    }\n\n    var span = new Span(eventPairs[i][2], 'hard-navigation.browser-timing');\n    var data = null;\n\n    if (eventPairs[i][0] === 'requestStart') {\n      span.pageResponse = true;\n      data = {\n        url: location.origin\n      };\n    }\n\n    span._start = start - baseTime;\n    span.end(end - baseTime, data);\n    spans.push(span);\n  }\n\n  return spans;\n}\n\nfunction createResourceTimingSpan(resourceTimingEntry) {\n  var name = resourceTimingEntry.name,\n      initiatorType = resourceTimingEntry.initiatorType,\n      startTime = resourceTimingEntry.startTime,\n      responseEnd = resourceTimingEntry.responseEnd;\n  var kind = 'resource';\n\n  if (initiatorType) {\n    kind += '.' + initiatorType;\n  }\n\n  var spanName = stripQueryStringFromUrl(name);\n  var span = new Span(spanName, kind);\n  span._start = startTime;\n  span.end(responseEnd, {\n    url: name,\n    entry: resourceTimingEntry\n  });\n  return span;\n}\n\nfunction isCapturedByPatching(resourceStartTime, requestPatchTime) {\n  return requestPatchTime != null && resourceStartTime > requestPatchTime;\n}\n\nfunction isIntakeAPIEndpoint(url) {\n  return /intake\\/v\\d+\\/rum\\/events/.test(url);\n}\n\nfunction createResourceTimingSpans(entries, requestPatchTime, trStart, trEnd) {\n  var spans = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var _entries$i = entries[i],\n        initiatorType = _entries$i.initiatorType,\n        name = _entries$i.name,\n        startTime = _entries$i.startTime,\n        responseEnd = _entries$i.responseEnd;\n\n    if (RESOURCE_INITIATOR_TYPES.indexOf(initiatorType) === -1 || name == null) {\n      continue;\n    }\n\n    if ((initiatorType === 'xmlhttprequest' || initiatorType === 'fetch') && (isIntakeAPIEndpoint(name) || isCapturedByPatching(startTime, requestPatchTime))) {\n      continue;\n    }\n\n    if (shouldCreateSpan(startTime, responseEnd, trStart, trEnd)) {\n      spans.push(createResourceTimingSpan(entries[i]));\n    }\n  }\n\n  return spans;\n}\n\nfunction createUserTimingSpans(entries, trStart, trEnd) {\n  var userTimingSpans = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var _entries$i2 = entries[i],\n        name = _entries$i2.name,\n        startTime = _entries$i2.startTime,\n        duration = _entries$i2.duration;\n    var end = startTime + duration;\n\n    if (duration <= USER_TIMING_THRESHOLD || !shouldCreateSpan(startTime, end, trStart, trEnd)) {\n      continue;\n    }\n\n    var kind = 'app';\n    var span = new Span(name, kind);\n    span._start = startTime;\n    span.end(end);\n    userTimingSpans.push(span);\n  }\n\n  return userTimingSpans;\n}\n\nvar NAVIGATION_TIMING_MARKS = ['fetchStart', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'connectEnd', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd'];\nvar COMPRESSED_NAV_TIMING_MARKS = ['fs', 'ls', 'le', 'cs', 'ce', 'qs', 'rs', 're', 'dl', 'di', 'ds', 'de', 'dc', 'es', 'ee'];\n\nfunction getNavigationTimingMarks(timing) {\n  var fetchStart = timing.fetchStart,\n      navigationStart = timing.navigationStart,\n      responseStart = timing.responseStart,\n      responseEnd = timing.responseEnd;\n\n  if (fetchStart >= navigationStart && responseStart >= fetchStart && responseEnd >= responseStart) {\n    var marks = {};\n    NAVIGATION_TIMING_MARKS.forEach(function (timingKey) {\n      var m = timing[timingKey];\n\n      if (m && m >= fetchStart) {\n        marks[timingKey] = parseInt(m - fetchStart);\n      }\n    });\n    return marks;\n  }\n\n  return null;\n}\n\nfunction getPageLoadMarks(timing) {\n  var marks = getNavigationTimingMarks(timing);\n\n  if (marks == null) {\n    return null;\n  }\n\n  return {\n    navigationTiming: marks,\n    agent: {\n      timeToFirstByte: marks.responseStart,\n      domInteractive: marks.domInteractive,\n      domComplete: marks.domComplete\n    }\n  };\n}\n\nfunction captureNavigation(transaction) {\n  if (!transaction.captureTimings) {\n    return;\n  }\n\n  var trEnd = transaction._end;\n\n  if (transaction.type === PAGE_LOAD) {\n    if (transaction.marks && transaction.marks.custom) {\n      var customMarks = transaction.marks.custom;\n      Object.keys(customMarks).forEach(function (key) {\n        customMarks[key] += transaction._start;\n      });\n    }\n\n    var trStart = 0;\n    transaction._start = trStart;\n    var timings = PERF.timing;\n    createNavigationTimingSpans(timings, timings.fetchStart, trStart, trEnd).forEach(function (span) {\n      span.traceId = transaction.traceId;\n      span.sampled = transaction.sampled;\n\n      if (span.pageResponse && transaction.options.pageLoadSpanId) {\n        span.id = transaction.options.pageLoadSpanId;\n      }\n\n      transaction.spans.push(span);\n    });\n    transaction.addMarks(getPageLoadMarks(timings));\n  }\n\n  if (isPerfTimelineSupported()) {\n    var _trStart = transaction._start;\n    var resourceEntries = PERF.getEntriesByType(RESOURCE);\n    createResourceTimingSpans(resourceEntries, state.bootstrapTime, _trStart, trEnd).forEach(function (span) {\n      return transaction.spans.push(span);\n    });\n    var userEntries = PERF.getEntriesByType(MEASURE);\n    createUserTimingSpans(userEntries, _trStart, trEnd).forEach(function (span) {\n      return transaction.spans.push(span);\n    });\n  }\n}\n\nexport { getPageLoadMarks, captureNavigation, createNavigationTimingSpans, createResourceTimingSpans, createUserTimingSpans, NAVIGATION_TIMING_MARKS, COMPRESSED_NAV_TIMING_MARKS };","map":null,"metadata":{},"sourceType":"module"}